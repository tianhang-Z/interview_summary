## 单例模式

一种创建型设计模式，确保一个类只有一个实例，并提供一个全局访问点。

#### 饿汉式

* 实例在程序启动时立即创建（类加载时初始化）。

* **线程安全**（C++11 起静态变量初始化是线程安全的）。

* 可能造成资源浪费（如果单例对象很大且未被使用）

```c++
class Singleton {
public:
    static Singleton& getInstance() {
        return instance;
    }

    // 删除拷贝构造函数和赋值运算符
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

private:
    Singleton() {}  // 私有构造函数
    ~Singleton() {} // 私有析构函数

    static Singleton instance; // 静态成员变量
};

// 在.cpp文件中初始化
Singleton Singleton::instance;// 程序启动时立即初始化
```

#### 懒汉式

- **实例在第一次调用 `getInstance()` 时才创建**（延迟初始化）。
- **需要额外处理线程安全问题**

```cpp
#include <mutex>

class Singleton {
public:
    static Singleton& getInstance() {
        std::lock_guard<std::mutex> lock(mutex);  // 加锁保证线程安全
        if (instance == nullptr) {
            instance = new Singleton();
        }
        return *instance;
    }

    // 删除拷贝构造函数和赋值运算符
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

private:
    Singleton() {}  // 私有构造函数
    ~Singleton() {} // 私有析构函数

    static Singleton* instance;
    static std::mutex mutex;  // 互斥锁
};

// 在.cpp文件中定义
Singleton* Singleton::instance = nullptr;
std::mutex Singleton::mutex;
```

#### 最佳实践 使用局部静态变量

```cpp
class Singleton {
public:
    static Singleton& getInstance() {
        static Singleton instance;  // C++11 保证局部静态变量线程安全
        return instance;
    }

    // 删除拷贝构造函数和赋值运算符
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

private:
    Singleton() {}  // 私有构造函数
    ~Singleton() {} // 私有析构函数
};
```

## CRTP

（Curiously Recurring Template Pattern，奇异递归模板模式）是一种 **C++ 模板元编程技术**

基类可以通过模板参数 `Derived` 访问派生类的成员，从而实现静态多态

CRTP 的核心思想是：

- 基类是一个模板类
- 派生类继承自以自身为模板参数的基类

```cpp
template <typename Derived>
class Base {
public:
    void interface() {
        // 调用派生类的实现
        static_cast<Derived*>(this)->implementation();
    }
    
    void implementation() {
        std::cout << "Base implementation\n";
    }
};

class Derived : public Base<Derived> {
public:
    void implementation() {
        std::cout << "Derived implementation\n";
    }
};
```



## 观察者模式